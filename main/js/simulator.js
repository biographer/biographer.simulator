var serverURL, controls;
var jSBGN;

/** 
 * The Simulator class represents the network, it's current state and also
 * it's update rules. It also contains private and privileged functions
 * to run the simulator, find attractors and plot the time series graph.
 * @constructor
 */
var Simulator = function() {
  
  this.running = false;
  this.scopes = false;
  
  var obj = this;
  var config;
  
  var net;
  var ruleFunctions = {};
  
  var iterationCount = 0;
  var plot;
  
  /**
   * Convert the update rule to a function.
   * @param {string} rule The update rule.
   * @returns {Function} The function for the update rule.
   */
  var makeFunction = function(rule) {
    // Match the node ids
    rule = rule.replace(/[A-Za-z0-9_]+/g, 
    function(text) { 
      if (text === 'true' || text === 'false')
        return text;
      return "state['" + text + "']"; 
    });
    // Create the function passing the current state as the first parameter
    return Function("state", "return " + rule + ";");
  };
  
  /**
   * Get the guess seed generated by libscopes from the server.
   */
  var applyGuessSeed = function() {
    
    $.ajax({
      url: serverURL + '/Simulate/InitialSeed',
      async: false,
      success: function(data) {
        var seed = JSON.parse(data), i;
        for (i in seed) {
          if(seed[i])
            net.state[i] = true;
          else
            net.state[i] = false;
        }
      }
    });
  };
  
  /**
   * Update the color of a node after every iteration
   * @param {string} id The node id.
   */
  var nodeColorUpdate = function(id) {
    var opacity;
    if (net.state[id]) 
      opacity = 1;
    else
      opacity = 0;
    $('#' + id + ' :eq(0)').css('fill', '#10d010')
      .animate({'fill-opacity':opacity}, config.simDelay);
  };
  
  /**
   * The event handler for clicking the Update rule button of the edit
   * rule dialog box.
   */
  var updateRule = function() {
    var rule = $('#textRule').val();
    var id = $('#textID').text();
    // Update the rule and it's corresponding function
    net.rules[id] = rule;
    ruleFunctions[id] = makeFunction(net.rules[id]);
    
    $('#buttonEdit').unbind('click', updateRule);
    $('#dialogEdit').dialog('close');
  }
  
  /**
   * The event handler for right clicking a node. Opens the Edit rule
   * dialog box.
   * @param {Event} e The event object.
   */
  var nodeRightClickEdit = function(e) {
    
    e.preventDefault();
    
    var id = $(this).attr('id');
    $('#textID').text(id);
    $('#textRule').val(net.rules[id]);
    $('#buttonEdit').click(updateRule);
    $('#dialogEdit').dialog('open');
  };
  
  /**
   * The event handler for left clicking a node. The node state is toggled.
   */
  var nodeClickToggle = function() { 
    
    var id = $(this).attr('id');
    // Toggle the node state
    net.state[id] = !net.state[id];
    nodeColorUpdate(id);
    
    // Start the simulation if the One click option is checked
    if(config.oneClick && !obj.running) 
      setTimeout(function() { obj.start(); }, config.simDelay);
  };
  
  /**
   * The event handler for hovering over a node. Displays the update rule
   * of a node.
   */
  var nodeHoverRule = function() {
    var id = $(this).attr('id');
    var rule = id + ' = ' + net.rules[id];
    // Create the info box
    $('<div/>', {id:'boxInfo', text: rule}).prependTo('#graphNetwork');
  };
  
  /**
   * The event handler for unhovering a node. The info box is deleted.
   */
  var nodeHoverRemove = function() {
    $('#boxInfo').remove();
  };
  
  /**
   * Generate a random color. 
   * @returns {string} The random color.
   */
  var randomColor = function() {
    var color = '#', i;
    // Get 6 random characters in hex
    for (i = 0; i < 6; i++) 
      color += Math.round(Math.random()*0xF).toString(16);
    return color;
  };
  
  /**
   * Create the Rickshaw Plotter.
   * @param {Array} nodes The list of nodes in the graph.
   * @param {Object} state The state of the network.
   */
  var createPlotter = function(nodes, state) {
    var i, timeSeries = [], id;
    
    // Generate the timeSeries Object for the plotter
    for(i in nodes) {
      id = nodes[i].id;
      timeSeries.push({ color: randomColor(), 
        data: [{x: 0, y: +state[id]}], name: id });
    }
    
    // Create the Graph, constant hold interpolation  
    plot = new Rickshaw.Graph({
      element: $("#plotArea")[0],
      width: 600,//$(window).width(),
      height: 400,//$(window).height(),
      renderer: 'line',
      interpolation: 'step-after',
      series: timeSeries
    });
    
    // Create the X & Y-axis, X is attached to the graph, whereas 
    // Y is separate
    var xAxis = new Rickshaw.Graph.Axis.Time({
      graph: plot
    });
    var yAxis = new Rickshaw.Graph.Axis.Y({
      graph: plot,
      orientation: 'left',
      tickFormat: Rickshaw.Fixtures.Number.formatKMBT,
      element: $('#axisY')[0]
    });
    
    // Create the legend, separate from the graph
    var legend = new Rickshaw.Graph.Legend({
      element: $('#legendNodes')[0],
      graph: plot
    });
    
    // Create the choice list for the nodes, attach to legend
    var shelving = new Rickshaw.Graph.Behavior.Series.Toggle({
      graph: plot,
      legend: legend
    });
    
    // Render the plot and select the first node
    plot.render();
    $('#legendNodes ul :eq(0) span ').trigger('click');
  };
  
  /**
   * Initialise the simulator. The initial states are calculated, the 
   * plotter is created and all the event handlers for the nodes are 
   * applied.
   * @param {jSBGN} jsbgn The network represented as a jSBGN object.
   * @param {number} simDelay The delay between successive iterations.
   * @param {Boolean} guessSeed Truth value for whether the guess seed for
   * SBML files should be applied.
   */
  this.initialise = function(jsbgn, settings) {
    net = jsbgn;
    config = settings;
    net.state = {};
    
    console.log('Initialising simulator');
    
    $('#buttonSimulate').click(this.start);
    $('#buttonAnalyse').click(this.attractorSearch);
    
    // Initialise the state of the network
    var i;
    for (i in net.rules) {
      if(net.rules[i].length !== 0)
        net.state[i] = controls.getInitialSeed();
    }
    if(this.scopes && config.guessSeed)
      applyGuessSeed();
      
    createPlotter(net.nodes, net.state);
    
    var svgNode;  
    for (i in net.state) {
      ruleFunctions[i] = makeFunction(net.rules[i]);
      
      // Get the node in the SVG and bind the event handlers
      svgNode = $('#' + i);
      if (svgNode !== null) {
        if(!this.scopes) {
          svgNode.hover(nodeHoverRule, nodeHoverRemove);
          svgNode.bind('contextmenu', nodeRightClickEdit);
        }
        svgNode.click(nodeClickToggle);
        nodeColorUpdate(i);
      }
    }
  };
  
  /**
   * Append the newly calculated node states to the graph
   * @param {Array} nodes The list of nodes in the graph.
   * @param {Object} state The state of the network.
   */
  var updatePlots = function(nodes, state) {
    for(i in nodes)
      plot.series[i].data.push({x: iterationCount, y: +state[nodes[i].id]});
    plot.render();
  };

  /**
   * Calculate the new state of the network using the update rules.
   * @returns {Array} A list of the changed nodes.
   */
  var sync = function(state) {
    var i, id;
    var changed = [];
    var newState = {};
    
    // Get the new states by calling the respective update rule functions
    for (i in net.state) {
      newState[i] = ruleFunctions[i](state);
      if (newState[i] !== state[i]) 
        changed.push(i);
    }
    // The update the synchronous, the state is updated only after all
    // the new states are calculated
    for (i in changed) {
      id = changed[i];
      state[id] = newState[id];
    }
    return changed;
  };
  
  /**
   * Run a single iteration. Call the run function after completing an
   * iteration.
   */
  var iterate = function() {
    var changed, i;
    changed = sync(net.state);  
    
    // Update the node colors after an iteration and call run again if
    // the Simulation has not reached steady state
    if (changed.length > 0) {  
      for (i in changed)
        nodeColorUpdate(changed[i]);
      setTimeout(function() { obj.run(); }, config.simDelay);	
    }
    else {
      console.log('Boolean network reached steady state.');
      obj.stop();
    }
  };
  
  /**
   * Export all states to JSON. Required for the simulation of SBML files
   * using libscopes on the server.
   * @param {Array} states A list of the states which have to exported.
   * @returns {string} The JSON string for the exported states.
   */
  var exportStateJSON = function(states) {	
    var i, j;
    var exportStates = [];
    // Loop over all states and convert Boolean to 0/1 for the Python
    // libscopes library
    for (i in states) {
      exportStates.push({});
      for (j in states[i]) {
        if(states[i][j])
          exportStates[i][j] = 1;
        else
          exportStates[i][j] = 0;
      }
    }
    return JSON.stringify(exportStates);
  };
  
  /**
   * Create temporary update rule functions for the new state of the 
   * network as returned by the server for SBML files.
   * @param {Object} state The state of the network as calculated by libscopes.
   */
  var updateNodeRules = function(state) {	
    var i;
    for (i in state) {
      if(state[i])
        ruleFunctions[i] = function() { return true; };
      else
        ruleFunctions[i] = function() { return false; };
    }
  };
  
  /**
   * Executes the simulator. Time series plots updated and libscopes
   * server side iteration called if required.
   */
  this.run = function() {

    if(!(this.running))
      return;
    
    updatePlots(net.nodes, net.state);  
    $('#textIteration').text(iterationCount++);
    
    // Get the next states from the current state, contact server if required  
    if (this.scopes) {
      $.ajax({
        url: serverURL + '/Simulate/Iterate',
        type: 'POST',
        data: { state : exportStateJSON([net.state]) },
        success: function (resp) {
          updateNodeRules(JSON.parse(resp));
          iterate();
        }
      });
    }
    else
       iterate();
  };
  
  /**
   * Generate a map for the state of the network.
   * @param {Object} state The state of the network.
   * @return {string} A map of the state of the network
   */
  var encodeMap = function(state) {  
    var map = '', i;  
    for (i in state) 
      map += +state[i];
    return map;  
  };
  
  /**
   * Decode the map of the state of the network
   * @param {string} map The map of the state of the network
   * @returns {Object} The state of the network
   */
  var decodeMap = function(map) {
    var state = {}, i, j = 0;
    for (i in net.state)
      state[i] =  Boolean(parseInt(map[j++], 10));
    return state;  
  };
  
  /**
   * Get some random initial states, used by the attractorSearch function.
   * @returns {Array} A list of states
   */
  var getInitStates = function() {
    var i, j;
    var initStates = [];
    for (i = 0; i < 30; i++) {
      initStates.push({});
      for (j in net.state) {
        initStates[i][j] = Boolean(Math.round(Math.random()));
      }
    }
    return initStates;
  };
  
  /**
   * The event handler for hovering over a node. Displays The state 
   * defined by the node for the network.
   */
  var nodeHoverStates = function() {
    var id = $(this).attr('id');
    // Get the state from the node id which is a map
    var state = decodeMap(id), i;
    var info = '';
    for (i in state)
      info += i + ': ' + state[i] + '<br>';
    // Generate the info box
    $('<div/>', {id:'boxInfo', html: info}).prependTo('#graphStateTransition');
  };
  
  /**
   * Assign the state defined by the node in the State transition graph
   * to the nodes in the Network graph.
   */
  var nodeClickStates = function() {
    var id = $(this).attr('id'), i;
    net.state = decodeMap(id);
    for(i in net.state)
      nodeColorUpdate(i);
  };
  
  /**
   * Import the generated Attractor network into the State Transition Graph
   * @param {sb.Document} doc The SBGN document for the graph.
   * @param {Array} attractors A list of attractors of the graph.
   */
  var drawAttractors = function(doc, attractors) {
    
    // Convert the SBGN document to jSBGN
    var jsbgn = new jSBGN(); 
    var tmp = JSON.parse(sb.io.write(doc, 'jsbgn'));
    jsbgn.nodes = tmp.nodes;
    jsbgn.edges = tmp.edges;
    
    // Import the State transition graph into a bui.Graph instance
    controls.importNetwork(jsbgn, '#graphStateTransition');
    
    // Bind the event handlers for the node
    var i, id;
    for (i in jsbgn.nodes) {
      id = '#' + jsbgn.nodes[i].id;
      $(id).hover(nodeHoverStates, nodeHoverRemove);
      $(id).click(nodeClickStates);
    }
    // Color all the attractors with a unique color for each attractor
    var cycle, j, color;
    for (i in attractors) {
      cycle = attractors[i];
      color = randomColor();
      for (j in cycle)
        $('#' + cycle[j] + ' :eq(0)').css('fill', color);
    }
  };
  
  /**
   * Calculate the attractors for the network graph and display a state
   * transition graph.
   */
  this.attractorSearch = function() {
    var doc = new sb.Document();
    doc.lang(sb.Language.AF);
    
    var i, j;
    var initStates = getInitStates();
    
    // Get the new states of the network imported from SBML files by
    // using libscopes running on the server
    if(obj.scopes) {
      var statesList;
      $.ajax({
        url: serverURL + '/Simulate/AttractorSearch',
        type: 'POST',
        async: false,
        data: { states : exportStateJSON(initStates) },
        success: function (resp) {
          // The new state list for all the initial states
          statesList = JSON.parse(resp);
        }
      });
    }
    
    // Loop over all the initial states to find the attractors
    var cycle, attractors = [];
    var map, prev, node, idx;
    var currStates, state;
    for (i in initStates) {
      state = initStates[i];
      currStates = [];
      prev = '';
      // Run the iterations for each initial state
      for(j = 0 ; ; j++) {
        // A map is used to match two states, faster than directly
        // comparing the objects
        map = encodeMap(state);
        node = doc.node(map);
        
        // If the map does not exist in the graph document, create it
        if(node !== null) {
          idx = currStates.indexOf(map);
          // If the map already exists in the visited node array it means
          // that we have found a attractor
          if (idx !== -1) {
            cycle = currStates.slice(idx);
            attractors.push(cycle);
          }
          // Create the connecting arc for the state transition graph
          if (prev.length > 0)
            doc.createArc(prev + '->' + map).type(sb.ArcType.PositiveInfluence).source(prev).target(map);
          break;
        }
        else {
          doc.createNode(map).type(sb.NodeType.SimpleChemical);
          if (prev.length > 0)
            doc.createArc(prev + '->' + map).type(sb.ArcType.PositiveInfluence).source(prev).target(map);
        }
        currStates.push(map);
        if(obj.scopes)
          updateNodeRules(statesList[i][j + 1]);
        // Get the new states
        sync(state);
        prev = map;
      }
    }
    
    drawAttractors(doc, attractors);
  };
  
  
  /**
   * Export the update rules to a R BoolNet file.
   * @returns {string} The R BoolNet file data.
   */
  this.exportRBoolNet = function() {
    var rbn = 'targets, factors\n';
    var i, r;
    
    // Replace the JS logical operators with those of R for each update
    // rule
    for (i in net.rules) {
      r = net.rules[i].replace(/&&/g, '&').replace(/\|\|/g, '|')
        .replace(/true/g, 'TRUE').replace(/false/g, 'FALSE');
      rbn += i + ', ' + r + '\n';
    }
    return rbn;
  };
  
  /**
   * Export the update rules to a Python BooleanNet file.
   * @returns {string} The Python BooleanNet file data.
   */
  this.exportPythonBooleanNet = function() {
    var pbn = '';
    var i, r;
    
    // Replace the JS logical operators with those of Python for each update
    // rule
    for (i in net.rules) {
      r = net.rules[i].replace(/&&/g, 'and').replace(/\|\|/g, 'or')
        .replace(/true/g, 'True').replace(/false/g, 'False')
        .replace(/[!]/g, 'not');
      pbn += i + '* = ' + r + '\n';
    }
    return pbn;
  };
  
  /**
   * Start the simulator. Bind/unbind the event handlers.
   */
  this.start = function() {
    // Update the variable tracking whether the simulator is running or not
    obj.running = true;
    $('#buttonSimulate').unbind('click', obj.start);
    $('#buttonSimulate').click(obj.stop);
    $('#buttonSimulate').button( "option", "icons", {primary: 'ui-icon-pause'});
    $('#circleProgress').show();
    $('#tabs').tabs('select', '#graphNetwork');
    // Start the simulation
    obj.run();
  };

  /**
   * Stop the simulator. Bind/unbind the event handlers.
   */
  this.stop = function() {
    obj.running = false;
    $('#buttonSimulate').unbind('click', obj.stop);
    $('#buttonSimulate').click(obj.start);
    $('#buttonSimulate').button( "option", "icons", {primary: 'ui-icon-play'});
    $('#circleProgress').hide();
  };
  
  /**
   * Destroy the simulator. All the event handlers are unbound.
   */
  this.destroy = function() {
    $('#buttonSimulate').unbind('click', obj.start);
    $('#buttonAnalyse').unbind('click', obj.attractorSearch);
  };
  
  
};
